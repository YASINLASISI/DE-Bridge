/**
 * Core Philosophy: This ruleset enforces a strict, user-centric security model. Data is primarily accessed based on explicit user ownership or documented participation in a shared resource. A separate `roles_admin` collection provides administrative override.
 *
 * Data Structure: User data is in `/users/{userId}`. Public expert profiles are in a denormalized `/experts/{expertId}` collection for efficient public listing. Shared data like `bookings` and `conversations` are in top-level collections.
 *
 * Key Security Decisions:
 * - Public Listing for Experts: The `/experts` collection is readable by anyone to allow browsing, but writable only by the expert themselves or an admin. This is a key change for performance.
 * - User Enumeration is Disabled: `list` operations on the top-level `/users` collection are disallowed to protect user privacy.
 * - Default Deny: Access is denied by default. All permissions must be explicitly granted.
 * - Admin Override: Users whose UID exists in the `/roles_admin` collection have broad read/write access.
 * - Shared Access via Denormalization: Access to shared documents (bookings, conversations) is controlled by denormalized ID fields (`seekerId`, `expertId`, `participantIds`) on the documents themselves.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isBookingParticipant(bookingData) {
      return request.auth.uid == bookingData.seekerId || request.auth.uid == bookingData.expertId;
    }

    function isConversationParticipant(conversationData) {
      return request.auth.uid == conversationData.participant1Id || request.auth.uid == conversationData.participant2Id;
    }

    function isRelatedBookingParticipant(docData) {
      let bookingDoc = get(/databases/$(database)/documents/bookings/$(docData.bookingId)).data;
      return isBookingParticipant(bookingDoc);
    }

    // --------------------------------
    // User & Profile Collections
    // --------------------------------

    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if false; // Prevent user enumeration
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId) || isAdmin();
    }
    
    match /users/{userId}/seeker_details/{docId} {
      allow read, write: if isOwner(userId) || isAdmin();
    }

    /**
     * @description Publicly readable expert profiles for browsing, but only the owner can modify their own profile.
     * @path /experts/{expertId}
     * @allow (get, list) by any user for browsing experts.
     * @allow (create, update) only by the user who owns the expert profile.
     * @principle Separates public queryable data from private user data for performance and security.
     */
    match /experts/{expertId} {
      allow get, list: if true;
      allow create, update: if isOwner(expertId) || isAdmin();
      allow delete: if isOwner(expertId) || isAdmin();
    }

    // --------------------------------
    // App Collections
    // --------------------------------

    match /bookings/{bookingId} {
      allow get: if (resource != null && isBookingParticipant(resource.data)) || isAdmin();
      allow list: if false;
      allow create: if isSignedIn() && isOwner(request.resource.data.seekerId);
      allow update, delete: if (resource != null && isBookingParticipant(resource.data)) || isAdmin();
    }

    match /conversations/{conversationId} {
      allow get: if (resource != null && isConversationParticipant(resource.data)) || isAdmin();
      allow list: if false;
      allow create: if isSignedIn() && (isOwner(request.resource.data.participant1Id) || isOwner(request.resource.data.participant2Id));
      allow update, delete: if (resource != null && isConversationParticipant(resource.data)) || isAdmin();
    }

    match /conversations/{conversationId}/messages/{messageId} {
      allow get, list: if isConversationParticipant(get(/databases/$(database)/documents/conversations/$(conversationId)).data) || isAdmin();
      allow create: if isConversationParticipant(get(/databases/$(database)/documents/conversations/$(conversationId)).data) && isOwner(request.resource.data.senderId);
      allow update, delete: if (isExistingOwner(resource.data.senderId)) || isAdmin();
    }

    match /reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isOwner(request.resource.data.reviewerId);
      allow update, delete: if (isExistingOwner(resource.data.reviewerId)) || isAdmin();
    }

    match /medicalTranslations/{translationId} {
      allow get: if (resource != null && isRelatedBookingParticipant(resource.data)) || isAdmin();
      allow list: if false;
      allow create: if isSignedIn() && isRelatedBookingParticipant(request.resource.data);
      allow update, delete: if (resource != null && isRelatedBookingParticipant(resource.data)) || isAdmin();
    }

    match /roles_admin/{userId} {
      allow read, write: if isAdmin();
    }
  }
}
